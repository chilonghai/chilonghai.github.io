<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Hexo搭建Blog]]></title>
      <url>%2F2016%2F12%2F22%2FHexo%E6%90%AD%E5%BB%BABlog%2F</url>
      <content type="text"><![CDATA[Hexo搭建博客 参考:Charly Cheng;附带具体步骤: . 搭建博客第一步：Hexo . 搭建博客第二步：GithubPages . 搭建博客第三步：域名购买及配置 . 搭建博客最终篇：博客的成功搭建 Hexo使用. 新建文件夹，执行npm install hexo-cli -g,安装Hexo; . 执行hexo init blog,下载blog模板; . cd blog执行npm install; . 执行hexo g #或hexo generate在当前目录生成一个名为public的静态文件; . 执行hexo s #或hexo server启动博客; . 浏览器打开http://localhost:4000/查看搭建结果; 注:①. hexo deploy或hexo d部署博客到远程服务器,如GitHub等;②. hexo new &#39;文章名称&#39;新建文章;③. hexo page &#39;页名称&#39;新建页面; Hexo主题设置. blog根目录执行hexo clean; . 执行git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia克隆主题; . 更新主题修改_config.yml文件中的theme属性,设置为yilia或其他主题; . 执行hexo generate重新生成配置项; . 执行hexo server启动服务,浏览器打开http://localhost:4000/查看主题修改结果; GitHub创建自己的blog仓库并关联hexo. Repository name的必要格式为chilonghai.github.io; . clone该项目到本地; . 拷贝GitHub上项目的ssh链接; . 修改hexo的_config.yml文件中的deploy属性为: 1234deploy: type: git repo: 你自己的SSH地址 branch: master . 执行hexo deploy;至此已完成部署; 域名解析. 登录万网首页,首先购买域名; . 已购买域名后,进行域名解析,记录值为192.30.252.153解析成功后即可通过域名访问blog了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单配置Mac下Vim开发环境]]></title>
      <url>%2F2016%2F12%2F21%2F%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AEMac%E4%B8%8BVim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[简单配置Mac下Vim开发环境 本人最终使用的适合Java开发的.vimrc这一配置，在此简单介绍几种可能以后需要用到的配置，以备不时之需。现有配置还不尽人意，有新的配置方案再行更新！ Mac下Vim简单配置(暂时未使用). 查看~/.vimrc文件是否存在，如果存在，备份之； . 执行cp /usr/share/vim/vimrc ~/.vimrc； . 编辑~/.vimrc文件，在文件尾添加如下代码块: 12345678910111213141516171819202122232425262728syntax onset nocompatibleset numberset autoindentset smartindentset showmatchset hlsset incsearchset shiftwidth=4set ts=4set rulerset mousehideset mouse=vset encoding=utf-8set fileencodings=utf-8,chinese,latin-1set visualbellif has(&quot;gui_running&quot;)-1set cursorline-1colorscheme murphy-1set background=dark-1set guifont=YaHei\ Consolas\ Hybrid:h14-1highlight Cursorline guibg=grey15-1set guioptions-=T-1set fileformat=unix-1set lines=49-1set columns=140-1set mouse=aendif 简单的配置完成！ 适合Java开发的.vimrc配置(暂时配合Solarized配色方案使用)适合Java开发的.vimrc配置GitHub链接 . 首先clone项目: 1git clone https://github.com/wsdjeg/DotFiles.git . 赋予install.sh执行权限并将该执行文件与vim做关联: 12chmod +x install.sh./install.sh vim # or ./install.sh nvim ./install.sh vim的执行结果如下: 12Move ~/.vimrc to ~/.vimrc_backLinking ~/.vim -&gt; /Users/tilkai/GitHub_Tools/DotFiles/config/nvim . 使用vim打开任意文本文件，此时将会执行: 1234567891011vi vimTest0.txt:!git clone https://github.com/Shougo/dein.vim /Users/tilkai/.cache/vimfiles/repos/github.com/Shougo/dein.vimCloning into &apos;/Users/tilkai/.cache/vimfiles/repos/github.com/Shougo/dein.vim&apos;...remote: Counting objects: 3847, done.remote: Compressing objects: 100% (72/72), done.remote: Total 3847 (delta 27), reused 0 (delta 0), pack-reused 3762Receiving objects: 100% (3847/3847), 732.36 KiB | 120.00 KiB/s, done.Resolving deltas: 100% (2203/2203), done.Checking connectivity... done.Press ENTER or type command to continue 以上配置完成！ Terminal并Vim、ls配置Solarized配色方案参考:在 Mac OS X 终端里使用 Solarized 配色方案 . GitHub下载源码: 1git clone git://github.com/altercation/solarized.git . 本人只是使用了其提供的Terminal配色方案，目录如下: 1234567tilkai @ localhost in ~/GitHub_Tools/solarized/osx-terminal.app-colors-solarized on git:master x [23:22:36] $ ls -ltotal 40-rw-r--r-- 1 tilkai staff 3330 12 21 22:45 README.md-rw-r--r-- 1 tilkai staff 5478 12 21 22:45 Solarized Dark ansi.terminal-rw-r--r-- 1 tilkai staff 5504 12 21 22:45 Solarized Light ansi.terminaldrwxr-xr-x 5 tilkai staff 170 12 21 22:45 xterm-256color 双击两个.terminal文件导入到Terminal配置中，在终端–》偏好设置中对Dark配置主题进行微调:①. 文本、粗体文本改为绿色；②. 光标透明度改为80% 配色方案配置完成！ 最终配置如下: (如需完全配置Solarized配色方案，参考给定原创blog链接！) 补充其他好的复杂配置: [https://github.com/geekan/source-insight-vim](https://github.com/geekan/source-insight-vim)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vi(Vim)键盘图及其基本命令]]></title>
      <url>%2F2016%2F12%2F21%2FVi-Vim-%E9%94%AE%E7%9B%98%E5%9B%BE%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[参考资料 Vi(Vim)键盘图及其基本命令 VIM键盘图 Vim的几种模式便于理解的区分模式正常模式：可以使用快捷键命令，或按:输入命令行。插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。可视模式：正常模式下按v可以进入可视模式，在可视模式下，移动光标可以选择文本。按V进入可视行模式，总是整行整行的选中。ctrl+v进入可视块模式。替换模式：正常模式下，按R进入。 (偏官方定义的)vi的工作模式命令行模式 （command mode）：控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。插入模式（Insert mode）：只有在 Insert mode 下，才可以做文字输入，按「ESC」键可回到命令行模式。底行模式（last line mode）：将文件保存或退出 vi，也可以设置编辑环境，如寻找字符串、列出行号等。 常用命令进入vivi filename打开或新建文件，并将光标置于第一行首 vi +n filename打开文件，并将光标置于第n行首 vi + filename打开文件，并将光标置于最后一行首 vi -r filename如果在上次使用vi编辑时发生系统崩溃，恢复文件 vi -R filename以只读的方式打开文件，但可以强制保存 vi file1....filen打开多个文件，依次编辑，如vi vimTest0.txt vimTest1.txt，输入:n切换到下一个文件，输入:N切换到上一个文件，详细参考vim 多文件编辑（偶的linux笔记） vi +/String filename打开文件，并将光标置于找到的第一个String行上，String区分大小写 命令行模式移动光标k、j、h、l功能分别等同于上、下、左、右箭头键 Ctrl+b在文件中向上移动一页（相当于 PageUp 键） Ctrl+f在文件中向下移动一页（相当于 PageDown 键） ctrl+u屏幕往后移动半页 ctrl+d屏幕往前移动半页 H将光标移到屏幕的最上行（Highest） nH将光标移到屏幕的第 n 行（如 2H： 将光标移到屏幕的第 2 行） M将光标移到屏幕的中间（Middle） L将光标移到屏幕的最下行（Lowest） nL将光标移到屏幕的倒数第 n 行（如 3L：将光标移到屏幕的倒数第 3 行） w在指定行内右移光标，到下一个字的开头 e在指定行内右移光标，到一个字的末尾 b在指定行内左移光标，到前一个字的开头 0数字0，左移光标，到本行的开头 G光标移动到文章的最后 gg光标移动到文章的开始 nG光标移动到文章的第 n 行（如8G：移动到文章的第 8行） $右移光标，到本行的末尾 ^移动光标，到本行的第一个非空字符 替换和删除rc用 c 替换光标所指向的当前字符 nrc用 c 替换包括光标所指向字符向后的 n 个字符（如 5rc： 用 c 替换包括光标所指向字符的后 5 个字符，举例:有abcdefg这些字符，光标指向d，输入3rn，得到abcnnng） x删除光标所在位置的字符 &lt;！– 暂时试验到这里，后面的未系统的尝试 –&gt; nx 删除光标所在位置后面的 n 个字符（如 3x：删除光标所在位置后面的 3 个字符） X 大写的 X，删除光标所在位置前面的一个字符 nX 删除光标所在位置前面的 n 个字符（如 3X ： 删除光标所在位置前面的 3 个字符） dd 删除光标所在行，并去除空隙 ndd 从光标所在行开始删除 n 行内容，并去除空隙（如 3dd： 删除 3 行内容，并去除空隙） 复制和粘贴从正文中删除的内容（如字符、字或行）并没有真正丢失，而是被剪切并复制到了一个内存缓冲区中。用户可将其粘贴到正文中的指定位置。 p 小写字母 p，将缓冲区的内容粘贴到光标的后面 P 大写字母 P，将缓冲区的内容粘贴到光标的前面 如果缓冲区的内容是字符或字，直接粘贴在光标的前面或后面；如果缓冲区的内容为整行正文则粘贴在当前光标所在行的上一行或下一行。 有时需要复制一段正文到新位置，同时保留原有位置的内容。这种情况下，首先应当把指定内容复制（而不是剪切）到内存缓冲区。完成这一操作的命令是： yy 复制当前行到内存缓冲区 nyy 复制 n 行内容到内存缓冲区（如 5yy： 复制 5 行内容到内存缓冲区） 搜索字符串/str1 正向搜索字符串 str1 n 继续搜索，找出 str1 字符串下次出现的位置 ?str2 反向搜索字符串 str2 撤销和重复u 撤消前一条命令的结果 . 重复最后一条修改正文的命令 文本选中 v 字符选中命令 V 行选中命令 插入模式进入插入模式i 在光标左侧输入正文 a 在光标右侧输入正文 o 在光标所在行的下一行增添新行 O 在光标所在行的上一行增添新行 I 在光标所在行的开头输入正文 A 在光标所在行的末尾输入正文 退出插入模式 ESC 键或组合键Ctrl+[ 底行模式在vi 的底行模式下，可以使用复杂的命令。 退出命令在命令模式下可以用 ZZ 命令退出 vi 编辑程序，该命令保存对正文所作的修改，覆盖原始文件。如果只需要退出编辑程序，而不打算保存编辑的内容，可用下面的命令： : q 在未作修改的情况下退出 : q! 放弃所有修改，退出编辑程序 行号和文件保存: n 将光标移到第 n 行 :set nu 显示行号 :set nonu 取消行号显示 底行模式下，可以规定命令操作的行号范围。数值用来指定绝对行号；字符“.”表示光标所在行的行号；字符“$”表示正文最后一行的行号；简单的表达式，例如“.+5”表示当前行往下的第 5 行。例如： : .+5 将光标移到当前行之后的第5行 : $ 将光标移到正文最后一行 在底行模式下，允许从文件中读取正文，或将正文写入文件。例如： :w 将编辑的内容写入原始文件，用来保存编辑的中间结果 :wq 将编辑的内容写入原始文件并退出编辑程序（相当于 ZZ 命令） :w file 将编辑的内容写入 file 文件，保持原有文件的内容不变 :a,bw file 将第 a 行至第 b 行的内容写入 file 文件 （如:1,.w file 将第 1 行至当前行写入 file 文件） :r file 读取 file 文件的内容，插入当前光标所在行的后面 :f file 将当前文件重命名为 file 字符串搜索:/str/ 正向搜索，将光标移到下一个包含字符串 str 的行 :?str? 反向搜索，将光标移到上一个包含字符串 str 的行 正文替换:s/str1/str2/ 用字符串 str2 替换行中首次出现的字符串 str1 :s/str1/str2/g 用字符串 str2 替换行中所有出现的字符串 str1 :.,$ s/str1/str2/g 用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1 :1,$ s/str1/str2/g 用字符串 str2 替换正文中所有出现的字符串 str1 :g/str1/s//str2/g 功能同上 从上述替换命令可以看到：g 放在命令末尾，表示对搜索字符串的每次出现进行替换；不加 g，表示只对搜索字符串的首次出现进行替换；g 放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作。 删除正文:d 删除光标所在行 :3d 删除第 3 行 :.,$d 删除当前行至正文的末尾 :/str1/,/str2/d 删除从字符串 str1 到 str2 的所有行 恢复文件vi 在编辑某个文件时，会另外生成一个临时文件，这个文件的名称通常以 . 开头，并以 .swp 结尾。vi 在正常退出时，该文件被删除，若意外退出，而没有保存文件的最新修改内容，则可以使用恢复命令，也可以在启动 vi 时利用 -r 选项。 :recover 恢复文件 选项设置为控制不同的编辑功能，vi 提供了很多内部选项。利用 :set 命令可以设置选项。基本语法为： :set option 设置选项 option 常见的功能选项包括： autoindent 设置该选项，则正文自动缩进 ignorecase 设置该选项，则忽略规则表达式中大小写字母的区别 number 设置该选项，则显示正文行号 ruler 设置该选项，则在屏幕底部显示光标所在行、列的位置 tabstop 设置按 Tab 键跳过的空格数。例如 :set tabstop=n，n 默认值为 8 mk 将选项保存在当前目录的 .exrc 文件中 shell切换在编辑正文时，利用 vi 底行模式下提供的shell 切换命令，无须退出 vi 即可执行Linux 命令 :! command 执行完shell 命令 command 后回到vi 另外，在命令模式下，键入K ，可命令 vi 查找光标所在单词的手册页，相当于运行man命令。 深入探索把VIM打造成一个简单实用的IDE Vim学习指南 快速学会 Vi编辑器 强大的Vim 编辑器 在CentOS 6.2上搭建Vim开发环境 CentOS 5.4 安装高亮Vim编辑工具 Vim技巧分享:C语言设置 Ubuntu中设置Vim的行号 Vim编辑器使用基础教程 Vim使用笔记]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何解决SpringBoot跨域问题]]></title>
      <url>%2F2016%2F12%2F21%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3SpringBoot%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[关于跨域 在网络上如果随便去请求其他服务器的资源，执行其他网站的脚本，是不利于自身安全的，于是，处于安全原因，浏览器都遵循着同源原则，拦截不同域名之间的请求。 详细说明参考: . HTTP access control (CORS) . 当它请求的一个资源是从一个与它本身提供的第一个资源的不同的域名时，一个资源会发起一个跨域HTTP请求(Cross-site HTTP request)。比如说，域名A ( http://domaina.example ) 的某 Web 应用程序中通过&lt; img&gt;标签引入了域名B( http://domainb.foo ) 站点的某图片资源(http://domainb.foo/image.jpg)，域名A的那 Web 应用就会导致浏览器发起一个跨站 HTTP 请求。在当今的 Web 开发中，使用跨站 HTTP 请求加载各类资源（包括CSS、图片、JavaScript 脚本以及其它类资源），已经成为了一种普遍且流行的方式。正如大家所知，出于安全考虑，浏览器会限制脚本中发起的跨站请求。比如，使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest 对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。为了能开发出更强大、更丰富、更安全的Web应用程序，开发人员渴望着在不丢失安全的前提下，Web 应用技术能越来越强大、越来越丰富。比如，可以使用 XMLHttpRequest发起跨站 HTTP 请求。（这段描述跨域不准确，跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是CSRF跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从HTTPS的域跨域访问HTTP，比如Chrome和Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。） 文／BeeNoisy（简书作者）原文链接：http://www.jianshu.com/p/f2060a6d6e3b著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。&gt; 整理众多解决SpringBoot跨域问题中的几种解决方案参考Spring Boot 之路[6]–允许跨域请求123456789101112131415161718192021222324252627282930313233package com.tsingyun.XXXX.center.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;/** * Created by tilkai on 2016/12/21. */@Configurationpublic class WebConfig &#123; private CorsConfiguration buildConfig() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); // 允许任何域名 corsConfiguration.addAllowedOrigin(&quot;*&quot;); // 允许任何头 corsConfiguration.addAllowedHeader(&quot;*&quot;); // 允许任何方法(post、get等) corsConfiguration.addAllowedMethod(&quot;*&quot;); return corsConfiguration; &#125; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, buildConfig()); return new CorsFilter(source); &#125;&#125; 参考Enabling Cross Origin Requests for a RESTful Web Service12345678910111213141516171819202122232425package com.tsingyun.XXXX.center.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;/** * Created by tilkai on 2016/12/21. */@Configurationpublic class WebConfig &#123; @Bean public WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/api/**&quot;); &#125; &#125;; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SpringDataJPA学习整理]]></title>
      <url>%2F2016%2F12%2F18%2FSpringDataJPA%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[JPA实体管理器 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实体管理器可以理解为数据库表和实体之间交互的桥梁，通过调用实体管理器相关方法可以把实体持久化到数据库中，也可以把数据库中记录打包成实体对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实体具有生命周期，这个生命周期指实体从创建到销毁在实体管理器方法管理下呈现出的状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图描述了实体生命周期以及实体管理器如何控制各个状态的实体:实体生命周期包括四个状态: 新建状态托管状态游离状态删除状态 即，插入一条记录，需要新建一个实体并向实体执行赋值操作，调用persist()方法，提交事务；修改实体有两种方法，一个是利用之前已经执行过添加或修改操作的实体(通常处于游离状态的实体)，调用merge()方法，并提交事务；另一个是通过条件查询出实体，修改实体属性，提交事务；删除操作要先根据条件查询出实体，调用remove()方法，提交事务； 简单代码实现增删改查UserRepository接口: 12345678public interface UserRepository extends JpaRepository&lt;User, Integer&gt; &#123; public void add(User user); // 添加 public User update(User user); // 修改 public User addOrUpdate(User user); // 添加或修改 public void delete(User user); // 删除 public User findOne(Integer id); // 查询单个实体 public List&lt;User&gt; findAll(); // 查询所有实体&#125; UserRepository实现类: 12345678910111213141516171819202122232425262728293031323334353637383940414243/** *使用Impl结尾，JPA会自动发现并使用该实现类 */public class UserRepositoryImpl &#123; //使用@PersistenceContext注解注入实体管理器 @PersistenceContext private EntityManager entityManager; @Transactional public void add(User user) &#123; entityManager.persist(user); &#125; @Transactional public User update()&#123; User userUpdate = entityManager.find(User.class, user.getId()); userUpdate.setAddress(user.getAddress); userUpdate.setPhone(user.getPhone); return userUpdate; &#125; @Transactional public User addOrUpdate(User user)&#123; return entityManager.merge(user); &#125; @Transactional public void delete(User user)&#123; entityManager.remove(user); &#125; public User fidOne(Integer id)&#123; return entityManager.find(User.class, id); &#125; public List&lt;User&gt; finddAll()&#123; String queryStr = &quot;select u from User u&quot;; Query query = entityManager.createQuery(queryStr); return query.getResultList(); &#125;&#125; 如何将实体属性分散到两个(或以上)表格中存放. 实体类加@SecondaryTables注解 1234567891011121314151617181920@Entity@Table(name = &quot;t_user&quot;)@SecondaryTables(&#123; @SecondaryTable(name = &quot;t_address&quot;, pkJoinColums = @PrimaryKeyJoinColum(name = &quot;address_id&quot;))&#125;)public class User&#123; @Id @GenerateValue @Column(name = &quot;id&quot;) private Integer id; // ... // 定义分散表格字段 @Column(table = &quot;t_address&quot;, name = &quot;street&quot;) private String street; // ...&#125; 内嵌实体. 使用@Embeddable注解，标识一个实体类，使该类可嵌入其他实体中； . 在使用@Embeddable标识实体的实体中，使用Embedded注解引入实体； . 可重命名实体的属性名称，如嵌入Comment实体： 123456@Embedded@AttributeOverrides(&#123; @AttributeOverride(name = &quot;title&quot;, column = @Column(name = &quot;newTitle&quot;)), @AttributeOverride(name = &quot;content&quot;, column = @Column(name = &quot;newContent&quot;))&#125;)private Comment comment; 一对一、一对多、多对多映射一对一映射如:主表为Person实体，从表为Address实体 12345678910111213141516171819public class Persion &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; //... /** * @JoinColumn定义主从表字段关联: * name属性定义主表外键字段 * referencedColumnName属性定义从表外键(一般为从表主键) * 如果是多字段关联，可以用: * @JoinColumns(value = &#123;@JoinColumn(), @JoinColumn(), ...&#125;) * 如果不指明@JoinColumn，默认是主键关联，且在主表中生成与从表主键相同名称、类型的外键； */ @OneToOne @JoinColumn(name = &quot;addressId&quot;, referencedColumnName = &quot;id&quot;) private Address address;&#125; 一对多映射方法1. 使用中间表进行一对多关联: 1234567891011121314151617@Entitypublic class Depart &#123; // ... // @JoinTable的name为中间表的名称， // joinColumns配置关系拥有者Depart实体与中间表的关联关系，(Depart表的dId关联中间表的departId) // inverseJoinColumns配置关系被拥有者Employee实体与中间表的关联关系，(Employee表的eId关联中间表的employeeId) // 注意，关系被拥有者为List， @OneToMany @JoinTable(name = &quot;depart_employee&quot;, joinColumns = @JoinColumn(name = &quot;departId&quot;, referencedColumnName = &quot;dId&quot;), inverseJoinColumns = @JoinColumn(name = &quot;employeeId&quot;, referencedColumnName = &quot;eId&quot;) ) private List&lt;Employee&gt; employees; // ...&#125; 方法2. 不使用中间表的外键关联: 123456789public class Depart &#123; // ... @OneToMany @JoinColumn(name = &quot;departId&quot;, referencedColumnName = &quot;id&quot;) private List&lt;Employee&gt; employees; // ...&#125; 多对多映射与一对多使用中间表的配置基本类似，修改@OneToMany为@ManyToMany 关于级联问题主表的增删操作是否对从表进行相应的增删操作，称之为级联问题。例如通过在@OneToOne注解中增加cascade配置项配置 123456789101112/** * cascade = ...的可选值 * ① CascadeType.DETACH * ② CascadeType.MERGE * ③ CascadeType.PERSIST * ④ CascadeType.REFRESH * ⑤ CascadeType.REMOVE 删除主表记录时将从表关联记录一并删除 * ⑥ CascadeType.ALL 所有操作都要级联从表操作 * 可选多个值:@OneToOne(cascade = &#123;CascadeType.DETACH, CascadeType.MERGE&#125;) */@OneToOne(cascade = ...) 懒加载如果查询主实体信息时，不希望查询出子实体的内容，而是在需要的时候去数据库中获取，此时可以使用懒加载JPA配置懒加载使用fetch = FetchType.LAZT JPA实体继承JPA继承策略: 单一表策略；连接表策略；每个类策略； 在父实体类上添加@Inheritance注解配置继承策略 单一表策略1234@Entity@Inheritance(strategy = InheritanceType.SINGLE_TABLE)public class A &#123;&#125; 如此，生成的数据库表中会有DTYPE字段，用以区分是哪个实体的属性；DTYPE叫’鉴别字段’，可选值默认为实体的类名； 当然JPA中可配置DTYPE别名和可选值的内容: 123456@Entity@Inheritance(strategy = InheritanceType.SINGLE_TABLE)@DiscriminatorColumn(name = &quot;ITYPE&quot;, discriminatorType = DiscriminatorType.CHAR) // DTYPE的别名@DiscriminatorValue(&quot;I&quot;) // DTYPE值配置，每个子类都需要添加该注解public class A &#123;&#125; 连接表策略InheritanceType.JOINED如父类A，子类B，子类C，每个实体类对应一张数据库表；三张表通过共享主键彼此关联； 每个类一个表策略JPA实体继承后面详细补充，以上关于实体继承的整理可能存在认知错误！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java细节与误区学习整理]]></title>
      <url>%2F2016%2F12%2F16%2Fjava%E7%BB%86%E8%8A%82%E4%B8%8E%E8%AF%AF%E5%8C%BA%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[Java几个细节和误区 double 0.1 + double 0.21System.out.println((double)0.1+(double)0.2); 输出结果 10.30000000000000004 追求高精度可以使用bigdecimal 死循环1234for(float f = 10.1f; f != 11; f+=0.1f)&#123; System.out.println(f);&#125; 导致原因：计算机使用二进制来存储数据，而很多小数都不能够准确地使用二进制来表示（事实上，大多数的小数都是近似的），就像使用十进制小数不能准确地表示1/3这样的分数一样。大多数的浮点型，在计算机中只是近似地存储其值，而不像整型那样准确地存储。 i+++j问题123int i = 3,j = 2;System.out.println(++i+j);System.out.println(i+++j); java中i+++j的计算:java中依据贪心规则，前置++优于后置++，计算结果为(i++)+j j=i++的底层实现: 1temp = i; i = i + 1； j = temp; 除以01System.out.println(100/0); 输出结果 1Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero 1System.out.println(100.0/0); 输出结果 1Infinity 1System.out.println(-100/0.0); 输出结果 1-Infinity 1System.out.println(0/0.0); 输出结果 1NaN 原因:浮点数有三个特殊值：①正无穷大Infinity,任何一个正浮点数/0得到,所有正无穷大相等 1System.out.println(100.0/0 == 99.0/0); 为 1true ②负无穷大-Infinity,任何一个负浮点数/0得到,所有负无穷大相等; ③非数NaN,通过0.0/0得到,非数和包括自己的所有非数都不相等 1System.out.println(0.0/0 == 0.0/0); 为 1false 奇偶判断1i % 2 == 1 与 1i % 2 != 0 的取舍或者使用 1(i &amp; 1) != 0 由于i % 2 == 1不能有效判断负数的奇偶性，因此推荐i % 2 != 0和(i &amp; 1) != 0的奇偶判断方式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单SVG学习整理]]></title>
      <url>%2F2016%2F12%2F16%2F%E7%AE%80%E5%8D%95SVG%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[简单SVG语法圆形、矩形、椭圆等简单代码 圆形简单代码 1&lt;circle cx = &quot;50&quot; cy = &quot;40&quot; r = &quot;40&quot; style = &quot;stroke : green; stroke-width : 4; stroke-opaciry : 0.9; fill : yellow; fill-opacity : 1; opacity : 1;&quot; /&gt; 关键字 cx、cy: 圆心x轴、y轴坐标; r: 圆半径; stroke: 边框颜色(也可使用RGB); stroke-width: 边框宽度; stroke-opacity: 边框透明度,数值范围从0-1; fill: 填充色; fill-opacity: 填充透明度; opacity: 整体透明度; 圆角矩形简单代码 1&lt;rect x = &quot;50&quot; y = &quot;20&quot; rx = &quot;20&quot; ry = &quot;20&quot; width = &quot;300&quot; hieght = &quot;100&quot; style = &quot;fill : rgh(0,0,255); stroke-width : 3; stroke : rgb(0,0,0); fill-opacity : 0.1; strok-opacity : 0.9;&quot; /&gt; 关键字 rx、ry: 矩形圆角x轴、y轴方向的半径; 椭圆简单代码 1&lt;ellipse cx = &quot;200&quot; cy = &quot;80&quot; rx = &quot;100&quot; ry = &quot;50&quot; .../&gt; 线、文本与多边形 直线 1&lt;line x1 = &quot;0&quot; y1 = &quot;0&quot; x2 = &quot;200&quot; y2 = &quot;200&quot; /&gt; 关键字 x1、y1: 直线起始x、y轴坐标; x2、y2: 直线终止x、y轴坐标; 折线 12&lt;polyline points = &quot;20,20 40,25 60,40 80,120 120,140 200,180&quot;style = &quot;fill : none; stroke : black; stroke-wiedth : 3;&quot; /&gt; 关键字 points 定义折线段的端点坐标，坐标与坐标间用空格分隔; fill : none; 定义折线交叉后的封闭区域不会填充颜色; 文本 1234&lt;text x = &quot;80&quot; y = &quot;100&quot; fill = &quot;blue&quot; transform = &quot;rotate(20 150,120)&quot;&gt;多行文本 - 第零行 &lt;tspan x = &quot;100&quot; y = &quot;120&quot; transform = &quot;rotate(20 150,120)&quot;&gt;多行文本 - 第一行&lt;/tspan&gt; &lt;tspan x = &quot;100&quot; y = &quot;140&quot; transform = &quot;rotate(20 150,120)&quot;&gt;多行文本 - 第二行&lt;/tspan&gt;&lt;/text&gt; 关键字 transform = “rotate(20 150,120)” 定义以150,120坐标点为旋转中心,旋转20度. 多边形 1&lt;polygon points = &quot;240,48 352,396 58,180 422,180 128,396&quot; style = &quot;fill : green; stroke : red; stroke-width : 3; fill-rule : nonzero;&quot;&gt;&lt;/polygon&gt; 关键字 fill-rule : 定义填充规则,用于判断一个点是否在图形内部的算法,可选值为nonzero,evenodd,inherit; 简单路径 path 1&lt;path d=&quot;M600 0 L500 200 L700 200 Z&quot;/&gt; 关键字 M : 移动画笔到指定坐标，不绘制; L : 从当前点绘制直线到指定点; Z : 从当前点做到起点的直线，构成闭合路径;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac下安装MariaDB]]></title>
      <url>%2F2016%2F12%2F14%2FMac%E4%B8%8B%E5%AE%89%E8%A3%85MariaDB%2F</url>
      <content type="text"><![CDATA[Mac下安装MariaDB 使用brew进行安装，安装brew后，检查brew是否安装成功;执行brew search mariadb查找brew库中是否存在mariaDB;执行brew install mariadb进行mariadb的安装操作; 查看MariaDB在Mac中的位置 执行find /usr/ -iname &quot;mysql&quot; 1234567891011/usr//local/bin/mysql/usr//local/Cellar/mariadb/10.1.19/bin/mysql/usr//local/Cellar/mariadb/10.1.19/include/mysql/usr//local/Cellar/mariadb/10.1.19/share/mysql/usr//local/etc/init.d/mysql/usr//local/etc/logrotate.d/mysql/usr//local/include/mysql/usr//local/share/mysql/usr//local/var/mysql/usr//local/var/mysql/mysqlfind: /usr//sbin/authserver: Permission denied 启动MariaDB服务 执行launchctl load /usr/local/opt/mariadb/homebrew.mxcl.mariadb.plist启动MariaDB服务; 使用MariaDB 执行mysql -uroot -p进入数据库(默认安装完成后, 用户名为root, 密码为空);此后可执行如show databases;等数据库操作; 停止MariaDB服务 执行launchctl unload /usr/local/opt/mariadb/homebrew.mxcl.mariadb.plist关闭MariaDB服务;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SpringBoot中RMI与Shiro集成]]></title>
      <url>%2F2016%2F12%2F13%2FSpringBoot%E4%B8%ADRMI%E4%B8%8EShiro%E9%9B%86%E6%88%90%2F</url>
      <content type="text"><![CDATA[简单RMI Demo实现 gradle依赖123456dependencies &#123; compile project(&apos;:common&apos;) compile(&apos;org.springframework.boot:spring-boot-starter-thymeleaf&apos;) compile(&apos;org.springframework.boot:spring-boot-starter-cache&apos;) compile(&apos;org.springframework.boot:spring-boot-devtools&apos;)&#125; 定义规范接口12345678package com.tsingyun.XXX.center.common;/** * Created by cuckoo on 06/12/2016. */public interface HelloService &#123; public String hello(String message);&#125; 服务提供方模块. 基于规范接口的接口实现类 123456789101112131415package com.tsingyun.XXX.center.dataServer.service;import com.tsingyun.XXX.center.common.HelloService;import org.springframework.stereotype.Service;/** * Created by cuckoo on 06/12/2016. */@Servicepublic class HelloServiceImpl implements HelloService &#123; @Override public String hello(String message) &#123; return &quot;Hello &quot;+message+&quot;!&quot;; &#125;&#125; . 服务暴露类 123456789101112131415161718192021222324252627package com.tsingyun.XXX.center.dataServer.rpc;import com.tsingyun.XXX.center.common.HelloService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.remoting.rmi.RmiServiceExporter;/** * Created by cuckoo on 06/12/2016. */@Configurationpublic class ServiceExporter &#123; @SuppressWarnings(&quot;SpringJavaAutowiringInspection&quot;) @Autowired private HelloService helloService; @Bean RmiServiceExporter helloServiceExporter() &#123; RmiServiceExporter helloServiceExporter = new RmiServiceExporter(); helloServiceExporter.setServiceName(&quot;HelloService&quot;); helloServiceExporter.setService(helloService); helloServiceExporter.setServiceInterface(HelloService.class); return helloServiceExporter; &#125;&#125; 服务调用方模块12345678910111213141516171819202122package com.tsingyun.XXX.center.dataClient.rpc;import com.tsingyun.XXX.center.common.HelloService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.remoting.rmi.RmiProxyFactoryBean;/** * Created by cuckoo on 06/12/2016. */@Configurationpublic class ServerImporter &#123; @Bean(name = &quot;helloService&quot;) public RmiProxyFactoryBean helloService() &#123; RmiProxyFactoryBean rmiProxyFactoryBean = new RmiProxyFactoryBean(); rmiProxyFactoryBean.setServiceInterface(HelloService.class); rmiProxyFactoryBean.setServiceUrl(&quot;rmi://127.0.0.1:1099/HelloService&quot;); return rmiProxyFactoryBean; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.tsingyun.XXX.center.dataClient.controller;import com.tsingyun.XXX.center.common.HelloMotanService;import com.tsingyun.XXX.center.common.HelloService;import com.weibo.api.motan.config.springsupport.annotation.MotanReferer;import com.weibo.api.motan.config.springsupport.annotation.MotanService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import javax.websocket.server.PathParam;/** * Created by cuckoo on 06/12/2016. * @RestController is a stereotype annotation that combines @ResponseBody and @Controller. * @RestController是@ResponseBody和@Controller的整合注释. */@RestControllerpublic class IndexController &#123; // 由于@Autowired为根据类型自动装配, 当spring上下文中存在不止一个HelloService类型的bean时, // 会抛出BeanCreationException异常, // 使用@Qualifier配合@Autowired来解决这些问题, // @Qualifier参数为@Service注解的类名, @SuppressWarnings(&quot;SpringJavaAutowiringInspection&quot;) @Autowired @Qualifier(&quot;helloService&quot;) private HelloService helloService; @RequestMapping(&quot;/&quot;) public String index(@PathParam(&quot;name&quot;) String name) &#123; return helloService.hello(name); &#125;&#125; RMI整合Shirogradle依赖12345678dependencies &#123; compile project(&apos;:common&apos;) compile(&apos;org.springframework.boot:spring-boot-starter-thymeleaf&apos;) compile(&apos;org.springframework.boot:spring-boot-starter-cache&apos;) compile(&apos;org.springframework.boot:spring-boot-devtools&apos;) compile(&quot;org.apache.shiro:shiro-spring:$springShiroVersion&quot;)&#125; 接口规范12345678910111213141516171819package com.tsingyun.XXX.center.common;import org.apache.shiro.authz.annotation.RequiresRoles;/** * Created by cuckoo on 06/12/2016. */public interface HelloService &#123; public String hello(String message); public String login(String username, String password); // 访问adminHello方法的前提是当前用户有admin角色 @RequiresRoles(&quot;admin&quot;) public String adminHello(String message); @RequiresRoles(&quot;user&quot;) public String userHello(String message);&#125; 服务端Shiro配置12345678910111213141516171819202122232425262728293031package com.tsingyun.XXX.center.dataServer.config;import org.apache.shiro.realm.Realm;import org.apache.shiro.realm.text.TextConfigurationRealm;import org.slf4j.LoggerFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Created by cuckoo on 10/12/2016. */@Configurationpublic class ShiroConfig &#123; private static org.slf4j.Logger log = LoggerFactory.getLogger(ShiroConfig.class); @Bean public Realm realm() &#123; TextConfigurationRealm realm = new TextConfigurationRealm(); // 参数格式含义:用户名 = 密码, 角色1, 角色2, 角色3 realm.setUserDefinitions(&quot;user=password,user\n&quot; + &quot;admin=password,admin&quot;); realm.setRoleDefinitions(&quot;admin=read,write\n&quot; + &quot;user=read&quot;); // 是否启用缓存 realm.setCachingEnabled(false); return realm; &#125;&#125; 服务端接口实现类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.tsingyun.XXX.center.dataServer.service;import com.tsingyun.XXX.center.common.HelloService;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.session.Session;import org.apache.shiro.subject.Subject;import org.slf4j.Logger;import org.springframework.stereotype.Service;/** * Created by cuckoo on 06/12/2016. */@Servicepublic class HelloServiceImpl implements HelloService &#123; private static final Logger log = org.slf4j.LoggerFactory.getLogger(HelloServiceImpl.class); @Override public String hello(String message) &#123; return &quot;Hello &quot;+message+&quot;!&quot;; &#125; @Override public String login(String username, String password) &#123; // 获取当前执行的用户 Subject subject = SecurityUtils.getSubject(); Session session = null; // subject.isAuthenticated() 一个被验证过的Subject主体调用isAuthenticated方法返回true, // Assert.assertEquals(true, subject.isAuthenticated()); //断言用户已经登录 if (subject.isAuthenticated())&#123; // session = subject.getSession(true), 获取session, 如果当前没有创建Session对象会创建一个, // subject.getSession(false), 当前没有创建Session则返回null, session = subject.getSession(false); &#125; else &#123; UsernamePasswordToken token = new UsernamePasswordToken(username, password, true); try &#123; subject.login(token); session = subject.getSession(false); &#125; catch (AuthenticationException exception) &#123; log.error(exception.getMessage()); &#125; &#125; if (session != null) &#123; // 当前会话唯一标识 return (String) session.getId(); &#125; else &#123; return null; &#125; &#125; @Override public String adminHello(String message) &#123; return &quot;Hello Admin &quot;+message+&quot;!&quot;; &#125; @Override public String userHello(String message) &#123; return &quot;Hello user &quot;+message+&quot;!&quot;; &#125;&#125; 服务暴露类123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.tsingyun.XXX.center.dataServer.rpc;import com.tsingyun.XXX.center.common.HelloService;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.spring.remoting.SecureRemoteInvocationExecutor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.remoting.rmi.RmiServiceExporter;/** * Created by cuckoo on 06/12/2016. */@Configurationpublic class ServiceExporter &#123; @SuppressWarnings(&quot;SpringJavaAutowiringInspection&quot;) @Autowired private HelloService helloService; @SuppressWarnings(&quot;SpringJavaAutowiringInspection&quot;) @Autowired private SecurityManager securityManager; /** * Spring远程安全确保每个远程方法调用都与一个负责安全验证的Subject绑定 * */ @Bean SecureRemoteInvocationExecutor secureRemoteInvocationExecutor() &#123; SecureRemoteInvocationExecutor secureRemoteInvocationExecutor = new SecureRemoteInvocationExecutor(); secureRemoteInvocationExecutor.setSecurityManager(securityManager); return secureRemoteInvocationExecutor; &#125; @Bean RmiServiceExporter helloServiceExporter() &#123; RmiServiceExporter helloServiceExporter = new RmiServiceExporter(); helloServiceExporter.setServiceName(&quot;HelloService&quot;); helloServiceExporter.setService(helloService); helloServiceExporter.setServiceInterface(HelloService.class); helloServiceExporter.setRemoteInvocationExecutor(secureRemoteInvocationExecutor()); return helloServiceExporter; &#125;&#125; 客户端接口调用类12345678910111213141516171819202122232425262728293031package com.tsingyun.XXX.center.dataClient.rpc;import com.tsingyun.XXX.center.common.HelloService;import org.apache.shiro.spring.remoting.SecureRemoteInvocationFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.remoting.rmi.RmiProxyFactoryBean;/** * Created by cuckoo on 06/12/2016. */@Configurationpublic class ServerImporter &#123; @Bean SecureRemoteInvocationFactory secureRemoteInvocationFactory() &#123; SecureRemoteInvocationFactory secureRemoteInvocationFactory = new SecureRemoteInvocationFactory(); return secureRemoteInvocationFactory; &#125; @Bean(name = &quot;helloService&quot;) public RmiProxyFactoryBean helloService() &#123; RmiProxyFactoryBean rmiProxyFactoryBean = new RmiProxyFactoryBean(); rmiProxyFactoryBean.setServiceInterface(HelloService.class); rmiProxyFactoryBean.setServiceUrl(&quot;rmi://127.0.0.1:1099/HelloService&quot;); rmiProxyFactoryBean.setRemoteInvocationFactory(secureRemoteInvocationFactory()); return rmiProxyFactoryBean; &#125;&#125; 客户端controller类1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.tsingyun.XXX.center.dataClient.controller;import com.tsingyun.XXX.center.common.HelloService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.websocket.server.PathParam;/** * Created by cuckoo on 06/12/2016. */@RestControllerpublic class IndexController &#123; @SuppressWarnings(&quot;SpringJavaAutowiringInspection&quot;) @Autowired @Qualifier(&quot;helloService&quot;) private HelloService helloService; @RequestMapping(&quot;/&quot;) public String index(@PathParam(&quot;name&quot;) String name) &#123; return helloService.hello(name); &#125; @RequestMapping(&quot;/login&quot;) public String login() &#123; String sessionId = helloService.login(&quot;user&quot;, &quot;password&quot;); if (sessionId != null) &#123; System.setProperty(&quot;shiro.session.id&quot;, sessionId); &#125; return sessionId; &#125; @RequestMapping(&quot;/adminhello&quot;) public String adminHello(@PathParam(&quot;name&quot;) String name) &#123; return helloService.adminHello(name); &#125; @RequestMapping(&quot;/userhello&quot;) public String userHello(@PathParam(&quot;name&quot;) String name) &#123; return helloService.userHello(name); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Apache-Shiro身份认证]]></title>
      <url>%2F2016%2F12%2F12%2FApache-Shiro%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%2F</url>
      <content type="text"><![CDATA[参考:【Shiro】Apache Shiro架构之身份认证（Authentication）官方文档 认证主体Authenticating Subjects验证一个主体分三步: Step 1: Collect the Subject’s principals and credentials获取主体的身份和凭证; 1234// 根据用户名、密码获取令牌(token)UsernamePasswordToken token = new UsernamePasswordToken(username, password);// 可选token.setRememberMe(true); Step 2: Submit the principals and credentials提交主体的身份和凭证; 1234// 得到当前执行的用户Subject currentUser = SecurityUtils.getSubject();// 进行认证currentUser.login(token); Step 3: Handling Success or Failure提交成功, 允许访问; 否则重新尝试身份验证或者阻止访问; 123456try &#123; currentUser.login(token);&#125; catch ( AuthenticationException ae ) &#123; //unexpected error? //Handel error&#125; Step4:logout当主体完成与应用程序交互, 可以调用subject.logout()方法放弃所有的身份信息, 删除所有的身份信息和Shiro会话; 1currentUser.logout(); . 认证主体包括两部分: 12Principals：身份。可以是用户名，邮件，手机号码等等，用来标识一个登录主体身份；Credentials：凭证。常见有密码，数字证书等等。 . Shiro可以从指定ini文件或从数据库中指定一个认证主体, 如使用ini文件指定认证主体: 123[users]user1=123456user2=123456 该ini文件制定了两个用户, user1和user2, 密码都是123456. 认证过程Authentication Sequence Step1 : 应用程序调用Subject.login(token)方法, 传入代表最终用户的身份和凭证构造的AuthenticationToken实例token;Step2 : 将Subject实例委托给应用程序的SecurityManager, 通过调用securityManager.login(token)开始认证工作;Step3,4,5 : SecurityManager根据具体的realm进行安全认证; realm可能是写在ini文件中的内容, 也可能是jdbc realm、jndi realm等; 身份认证示例. pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt; Spring集成则是: 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt; . ini文件存放用户名密码: 12[users]tilkai=123456 . 身份认证Java代码: 12345678910111213141516171819202122232425public class TextRealm &#123; public static void main(String[] args) &#123; // 读取配置文件，初始化SecurityManager工厂 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); // 获取securityManager实例 SecurityManager securityManager = factory.getInstance(); // 把securityManager实例绑定到SecurityUtils SecurityUtils.setSecurityManager(securityManager); // 创建token令牌，用户名/密码 UsernamePasswordToken token = new UsernamePasswordToken(&quot;tilkai&quot;, &quot;123456&quot;); // 得到当前执行的用户 Subject currentUser = SecurityUtils.getSubject(); try&#123; // 身份认证 currentUser.login(token); System.out.println(&quot;身份认证成功！&quot;); &#125;catch(AuthenticationException e)&#123; e.printStackTrace(); System.out.println(&quot;身份认证失败！&quot;); &#125; // 退出 currentUser.logout(); &#125;&#125; JDBC RealmJdbcRealm.ini 123456789101112131415#数据源选择的是c3p0dataSource=com.mchange.v2.c3p0.ComboPooledDataSourcedataSource.driverClass=com.mysql.jdbc.DriverdataSource.jdbcUrl=jdbc:mysql://localhost:3306/db_shirodataSource.user=rootdataSource.password=root#定义一个jdbc的realm，取名为jdbcRealmjdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm#jdbcRealm中有个属性是dataSource，选择我们上边定义的dataSourcejdbcRealm.dataSource=$dataSource#SecurityManager中的realm选择上面定义的jdbcRealmsecurityManager.realms=$jdbcRealm]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Apache-Shiro简介]]></title>
      <url>%2F2016%2F12%2F12%2FApache-Shiro%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[官方文档参考:Apache Shiro 简介第一章 Shiro简介——《跟我学Shiro》黑马张开涛Shiro源码参考实例 Apache Shiro : 用于身份验证和授权的框架.身份验证 : 指验证用户身份.(如常见验证身份的方法有:用户名和密码的组合,指纹,证书等).授权 : 身份验证成功后, 授权进行接管, 以便进行访问的限制或允许. Shiro可以帮助我们完成：认证、授权、加密、会话管理、与Web集成、缓存等。 Shiro基本功能点:Ahthentication : 身份认证/登录, 验证用户是不是拥有相应的身份;Authorization : 授权, 即权限验证, 验证某个已认证的用户是否拥有某个权限;Session Manager : 回话管理, 用户登录后就是一次会话, 在没有退出前, 用户的所有信息都在该会话中, 会话可以是普通JavaSE环境的, 也可以是如Web环境的;Cryptography : 加密, 保护数据的安全, 如密码加密存储到数据库中等;Web Support : 集成到WEB环境;Concurrency : shiro支持多线程应用的并发验证, 即如在一个线程中开启另一个线程, 能把权限自动传播过去;Testing : 测试支持;Run As : 允许一个用户假装另一个用户(如果他们允许)的身份进行访问;Remember Me : 记住我; 但是!Shiro不会去维护用户、维护权限, 这些需要我们自己去设计/提供, 然后通过相应的接口注入给Shiro. 从外部和内部来看一下Shiro框架对于一个好的框架, 从外部来看, 应该具有非常简单易于使用的API, 且API契约明确; 从内部来看, 其应该有一个可拓展的架构, 即非常容易插入用户的自定义实现, 因为任何框架都不能满足所有需求; 外部来看Shiro工作流程 由图, 应用代码直接交互的对象是Subject, 也就是说Shiro的对外API核心就是Subject; Subject : 主体, 代表当前”用户”, “用户”不一定是一个具体的人, 与当前应用交互的任何东西都是sbuject, 像网络爬虫, 机器人等, “用户”是一个抽象概念; 所有Subject都绑定到SecurityManager, 与Subject的所有交互都会委托给SecurityManager, 可以把Subject认为是一个门面, SecurityManager才是实际的执行者;SecurityManager : 安全管理器, 即所有与安全有关的操作都会与SecurityManager交互, 且它管理着所有Subject, 可以看出它是Shiro的核心, 其负责与其他组件交互, 相当SpringMVC中的DispatcherServlet前端控制器;Realm : 域, Shiro从Realm获取安全数据(例如用户, 角色, 权限), 就是说SecurityManager要验证用户身份, 需要从Realm获取相应的用户进行比较以确定用户身份是否合法, 也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作, 可以把Realm看成DataSource, 即安全数据源; 于是, 最简单的Shiro应用: 应用代码通过Subject来进行认证和授权, Subject委托给SecurityManager; 给Shiro的SecurityManager注入Realm, SecurityManager获取用户及权限进行判断; 由此可见, Shiro没有提供维护用户/权限的功能, 这些需要开发者通过Realm注入; 内部来看Shiro工作流程 Subject : 由图看出, Subject可以是任何可以跟应用交互的”用户”;SecurityManager : 相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher, 所有具体的交互都通过SecurityManager进行控制, 它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理;Authenticator : 认证器, 负责主体认证, 这是一个扩展点, 如果用户觉得Shiro默认的不好, 可以自定义实现; 其需要认证策略(Authentication Strategy), 即什么情况下算用户认证通过了;Authrizer : 授权器, 或者叫访问控制器, 用来决定主体是否有权限进行相应的操作, 即控制着用户能访问应用中的哪些功能;Realm : 可以有1个或多个Realm, 可以认为是安全实体数据源, 即用于获取安全实体的, 可以是JDBC实现, 可以是LDAP实现或者内存实现等, 由用户提供; 注意, Shiro不知道你的用户/权限存储在哪及以何种格式存储, 所以我们一般在应用中都需要实现自己的Realm;SessionManager : 如果写过Servlet就应该知道Session的概念, Session需要有人去管理它的生命周期, 这个组件就是SessionManager, 而Shiro并不仅仅可以用在Web环境, 也可以用在如普通的JavaSE环境、EJB等环境, 所以, Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据, 这样的话, 比如我们在Web环境用, 刚开始是一台Web服务器, 接着又上了台EJB服务器, 这时想把两台服务器的会话数据放到一个地方, 这个时候就可以实现自己的分布式会话(如把数据放到Memcached服务器);SessionDAO : 如果我们想把Session保存到数据库, 那么可以实现自己的SessionDAO, 通过如JDBC等操作写入数据库; 此外Session还可以使用Cache缓存, 以提高性能;CacheManager : 缓存控制器, 用来管理像用户、角色、权限等的缓存的, 因为这些数据基本上很少去改变, 放到缓存中后可以提高访问的性能;Cryptography : Shiro提供了密码加密/解密组件;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate基本查询操作]]></title>
      <url>%2F2016%2F12%2F11%2FHibernate%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[查询实体类全部属性的所有实例对象(查询所有记录) 1234567891011121314try &#123; Session session = HibernateUtils.getSession(); Transaction transaction = session.beginTransaction(); // User 实体类名称 可以写类的全限定名 // from User 等同于 SQL中 select * from user; String hql = &quot;FROM User&quot;; Query query = session.createQuery(hql); List&lt;User&gt; list = (List&lt;User&gt;)query.list(); transaction.commit();&#125; catch (HibernateException e) &#123; if (transaction != null) &#123; transaction.rollback(); &#125;&#125; 查询实体类全部属性的单个实例对象(查询一条记录)123Sring hql = &quot;FROM User&quot;;// 查询唯一的一条记录 (满足条件的第一条)session.createQuery(hql).setMaxResults(1).uniqueResult(); 查询实体类的部分属性(投影查询)123// id name 为 User对象中的id name属性Query query = session.createQuery(&quot;SELECT id, name FROM User&quot;);List&lt;Object[]&gt; list = query.list(); 注意,这种查询返回的是List. 实例化投影查询结果直接投影查询出来的List可能不好使用,可以在对应实体类中添加初始化这些属性的构造方法,可以把投影查询出来的某几列数据放在某个对象里,这样得到的将是一个一个的对象,而非Object[]. 12345// 如需要查询User实体的userName, age属性, 可在User类中添加如下构造方法public User (String userName, int age) &#123; this.userName = userName; this.age = age;&#125; 查询语句修改为: 1234// 解析HQL语句: 将查询出的userName, age放入User对象中String hql = &quot;SELECT new User(a.userName, a.age) FROM User a&quot;;Query query = session.creatQuery(hql);List&lt;User&gt; list = (List&lt;User&gt;)query.list(); 指定待查询实体类的别名12// 使用关键字AS指定实体类的别名,也可以直接加别名(如: FROM User a)String hql = &quot;SELECT a.userName, a.age FROM User AS a&quot;; 查询User实体所有属性所有记录也可以使用如下写法: 1String hql = &quot;SELECT u FROM User u&quot;; WHERE条件语句WHERE条件中可使用的运算符: . .号(别名.属性) . 比较运算符(= || &gt; || &gt;= || &lt; || &lt;= || &lt;&gt; || is null || is not null ) . 范围运算符(in || not in || between || not between) . 模式匹配符(like “字符串”) . 逻辑运算符(and(与) || or(或) || not(非)) . 集合运算符(is empty || is not empty) 案例: 12// 注意临界值 此处为包括1但不包括10 具体临界值建议自行执行HQL尝试整理归纳(我也不确定)String hql = &quot;FROM User a WHERE a.id not between (1 and 10)&quot;; HQL函数库常见: . 字符串相关 . 数字相关 . 集合相关 . 时间、日期 字符串相关 upper(s) : 转化成大写lower(s) : 转化成小写concat(s1, s2) : 连接substring(s, offset, length) : 截取字符串length(s)trim([[both|leading|trailing] char [from]] s)locate(search, s, offset) 数字相关 abs(n) : 绝对值sart(n) : 取余mod(dividend, divisor) 集合相关 size(c) : 返回集合中元素个数 时间、日期 current_date() : 返回当前系统日期current_time() : 返回当前系统时间current_timestamp() : 返回当前系统时间戳year(d) || month(d) || day(d) || hour(d) || minute(d) || second(d) : 获取参数d的指定数值(d的年||月||日||时||分||秒) 案例12// 投影查询User实体中userName、age属性的所有记录,并对查询出的userName做大写转化, 对查询出的age属性做取绝对值操作String hql = &quot;SELECT new User(upper(u.userName), abs(u.age)) FROM User u)&quot;; WHERE子句参数绑定由于WHERE子句中经常需要动态设置查询参数, Hibernate提供了了两种参数绑定方式. 按照参数名称绑定1234567// 可能注意的地方 =:id之间可不可以加空格, 加在哪边不会出问题(请自行测试)String hql = &quot;FROM User u WHERE u.id =:id AND u.userName =:userName&quot;;Session session = HibernateUtils.getSession();Query query = session.createQuery(hql);query.setInteger(&quot;id&quot;, 3);query.setString(&quot;userName&quot;, &quot;tilkai&quot;);List&lt;User&gt; list = List&lt;User&gt;query.list(); 按照参数位置绑定(按照?占位符下标绑定)12345678String hql = &quot;FROM User u WHERE u.id = ? or a.userName = ?&quot;;Session session = HibernateUtils.getSession();Query query = session.creatQuery(hql);// 0为占位符的下标query.setInteger(0, 3);// 1为占位符的下标query.setString(1, &quot;tilkai&quot;);List&lt;User&gt; list = List&lt;User&gt;query.list(); 去重(DISTINCT关键字)12// Hibernate中DISTINCT关键字只能去掉数据库中所有记录信息都相同的记录(如存在两个完全相同的user为tilkai的记录则可以去重,如果两个tilkai年龄不同,则不能去重)String hql = &quot;SELECT DISTINCT u.userName FROM User u&quot;; 排序(ORDER BY关键字)12// 默认升序String hql = &quot;FROM User ORDER BY id DESC&quot;; 聚合函数查询结果作为long返回.有5个聚合函数. . CONUT()统计符合条件的记录条数 . SVG()求平均值 . SUM()求和 . MAX()求最大值 . MIN()求最小值 案例1String hql = &quot;SELECT MAX(u.id) FROM User u&quot;; GROUP BY分组查询,经常与聚合函数组合使用 1String hql = &quot;SELECT COUNT(u.id), u.age FROM User u GROUP BY u.age&quot;; HAVING搭配GROUP BY关键字使用, 对分组后的记录进行筛选 12// 按年龄分组, 将每组平均年龄&gt;20的组查询出来String hql = &quot;SELECT u.age FROM User u GROUP BY u.age HAVING AVG(u.age) &gt; 10&quot;; 分页查询Query接口提供了两个用于分页展示查询结果的方法: . setFirstResult(int firstResult) : 设置开始查询的开始记录的位置; . setMaxResult(int maxResults) : 每页显示的最大记录的条数; 1234Query query = session.createQuery(&quot;FROM User&quot;);List list = query.setFirstResult(9) .setMaxResult(10) .list(); 批量更新删除Hibernate3之后, HQL新增update和delete语句 1234567// 在DELETE操作时,DELETE FROM User也可以(FROM关键字不是必须的)String delHql = &quot;DELETE User WHERE userName LIKE :userName&quot;;Query delQuery = session.createQuery(delHql);delQuery.setString(&quot;userName&quot;, &quot;til&quot;);// i &gt; 0, delete success; i &lt;=0 delete field;int i = delQuery.executeUpdate(); 1String uptHql = &quot;UPDATE User SET userName = &apos;tilkai&apos; WHERE id=:id&quot; 命名查询命名查询 : 将HQL查询语句编写在关系映射文件中, 在程序中通过session的getNameQuery()方法获取该查询语句. 命名查询的配置12345&lt;!-- Account.hbm.xml --&gt;&lt;!-- CDATA告诉XML解析器, 不要对其中内容进行解析 --&gt;&lt;query name = &quot;accountHql&quot;&gt; &lt;![CDATA[FROM Account]]&gt;&lt;/query&gt; 命名查询语句可以为HQL或SQL语句,程序代码也不区分命名查询语句的类型, 一律通过Session的getNameQuery()方法来获得查询语句.具体应用: 12// 参数为query标签的name属性Query query = session.getNameQuery(&quot;accountHql&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Blog主题优化(1)]]></title>
      <url>%2F2016%2F12%2F09%2FBlog%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96(1)%2F</url>
      <content type="text"><![CDATA[NexT主题的页脚官方Logo修改 原图: 首先定位文件: 12$ pwd/Users/tilkai/GitHub_Blog/blog/themes/hexo-theme-next/layout/_partials/footer.swig 三段代码: . “日期❤ XXX” 1&lt;span class=&quot;author&quot; itemprop=&quot;copyrightHolder&quot;&gt;&#123;&#123; config.author &#125;&#125;&lt;/span&gt; . “由Hexo强力驱动” 123&lt;div class=&quot;powered-by&quot;&gt; &#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&lt;/div&gt; . “主题-…” 1234&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; - &lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt; NexT.&#123;&#123; theme.scheme &#125;&#125; &lt;/a&gt; 中文处理: 12$ pwd/Users/tilkai/GitHub_Blog/blog/themes/hexo-theme-next/languages/zh-Hans.yml 修改footer下的powered和theme的值; 参考:Hexo-Next底部powered by的logo栏更改以及注意事项 资源链接BlogのIcons HexoのThemes Hexo首页设置展示部分信息Hexo推荐加入代码手动截断MarkDown文档中在适当位置加入&lt;!-- more --&gt;进行手动截断,界面将展示部分文章内容,并展示&lt;阅读全文&gt;按钮; 示例: 1234567# 基于Spring boot实现Motan Demo## 简单描述Motan框架Motan架构包括:&lt;1&gt;. 服务提供方`Server`&lt;!-- more --&gt;&lt;2&gt;. 服务调用方`Client`&lt;3&gt;. 注册中心`Registry` 展示结果: 个人暂定在文章开始标题后添加&lt;!-- more --&gt;以截取固定长预览内容; 其他方法参考:如何设置「阅读全文」？其中还给出了设置首页和归档页面展示自定义文章篇数的操作. 使用七牛云存储给Blog添加图床Hexo文章图片存储选七牛（当然支持MD都可以）教程很详细,从注册到配置使用的教程都有。 后期可整理给七牛云图片链接加防盗链。 使用LeanCloud给Blog添加阅读次数统计功能LeanCloud给Blog添加阅读次数统计功能基本配置参考为NexT主题添加文章阅读量统计功能 . leancloud官网注册账号并登录； . 打开控制台 . 创建新应用 . 新建Class用来专门保存我们博客的文章访问量等数据注意，此处的Class名称必须为Counter复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh 这个时候重新生成部署Hexo博客，应该就可以正常使用文章阅读量统计的功能了。需要特别说明的是：记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。 leancloud更详细配置参考:为NexT主题添加文章阅读量统计功能 添加百度/谷歌/本地 自定义站点内容搜索安装 hexo-generator-searchdb，在站点的根目录(如我的站点根目录:/Users/tilkai/GitHub_Blog/blog)下执行以下命令: 1npm install hexo-generator-searchdb --save 执行结果: 12345678910111213# tilkai @ localhost in ~/GitHub_Blog/blog [11:43:28]$ npm install hexo-generator-searchdb --save&gt; hexo-util@0.6.0 postinstall /Users/tilkai/GitHub_Blog/blog/node_modules/hexo-generator-searchdb/node_modules/hexo-util&gt; npm run build:highlight&gt; hexo-util@0.6.0 build:highlight /Users/tilkai/GitHub_Blog/blog/node_modules/hexo-generator-searchdb/node_modules/hexo-util&gt; node scripts/build_highlight_alias.js &gt; highlight_alias.jsonhexo-site@0.0.0 /Users/tilkai/GitHub_Blog/blog└─┬ hexo-generator-searchdb@1.0.3 └── hexo-util@0.6.0 编辑 站点配置文件(博客根目录下的_config.yml)，新增以下内容到任意位置: 12345search: path: search.xml field: post format: html limit: 10000 配置完成后效果图:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[中华万年历抓包中国天气API接口]]></title>
      <url>%2F2016%2F12%2F09%2F%E4%B8%AD%E5%8D%8E%E4%B8%87%E5%B9%B4%E5%8E%86%E6%8A%93%E5%8C%85%E4%B8%AD%E5%9B%BD%E5%A4%A9%E6%B0%94API%E6%8E%A5%E5%8F%A3%2F</url>
      <content type="text"><![CDATA[JSON格式数据的API 1234// 通过城市名字获得天气数据http://wthrcdn.etouch.cn/weather_mini?city=北京// 通过城市ID获取天气数据http://wthrcdn.etouch.cn/weather_mini?citykey=101010100 返回数据: 1&#123;&quot;desc&quot;:&quot;OK&quot;,&quot;status&quot;:1000,&quot;data&quot;:&#123;&quot;wendu&quot;:&quot;-2&quot;,&quot;ganmao&quot;:&quot;天气较凉，较易发生感冒，请适当增加衣服。体质较弱的朋友尤其应该注意防护。&quot;,&quot;forecast&quot;:[&#123;&quot;fengxiang&quot;:&quot;无持续风向&quot;,&quot;fengli&quot;:&quot;微风级&quot;,&quot;high&quot;:&quot;高温 3℃&quot;,&quot;type&quot;:&quot;晴&quot;,&quot;low&quot;:&quot;低温 -6℃&quot;,&quot;date&quot;:&quot;23日星期三&quot;&#125;,&#123;&quot;fengxiang&quot;:&quot;无持续风向&quot;,&quot;fengli&quot;:&quot;微风级&quot;,&quot;high&quot;:&quot;高温 4℃&quot;,&quot;type&quot;:&quot;晴&quot;,&quot;low&quot;:&quot;低温 -6℃&quot;,&quot;date&quot;:&quot;24日星期四&quot;&#125;,&#123;&quot;fengxiang&quot;:&quot;无持续风向&quot;,&quot;fengli&quot;:&quot;微风级&quot;,&quot;high&quot;:&quot;高温 4℃&quot;,&quot;type&quot;:&quot;多云&quot;,&quot;low&quot;:&quot;低温 -5℃&quot;,&quot;date&quot;:&quot;25日星期五&quot;&#125;,&#123;&quot;fengxiang&quot;:&quot;无持续风向&quot;,&quot;fengli&quot;:&quot;微风级&quot;,&quot;high&quot;:&quot;高温 5℃&quot;,&quot;type&quot;:&quot;霾&quot;,&quot;low&quot;:&quot;低温 -5℃&quot;,&quot;date&quot;:&quot;26日星期六&quot;&#125;,&#123;&quot;fengxiang&quot;:&quot;无持续风向&quot;,&quot;fengli&quot;:&quot;微风级&quot;,&quot;high&quot;:&quot;高温 5℃&quot;,&quot;type&quot;:&quot;晴&quot;,&quot;low&quot;:&quot;低温 -5℃&quot;,&quot;date&quot;:&quot;27日星期天&quot;&#125;],&quot;yesterday&quot;:&#123;&quot;fl&quot;:&quot;3-4级&quot;,&quot;fx&quot;:&quot;北风&quot;,&quot;high&quot;:&quot;高温 0℃&quot;,&quot;type&quot;:&quot;晴&quot;,&quot;low&quot;:&quot;低温 -8℃&quot;,&quot;date&quot;:&quot;22日星期二&quot;&#125;,&quot;aqi&quot;:&quot;37&quot;,&quot;city&quot;:&quot;北京&quot;&#125;&#125; XML格式的API1234// 通过城市ID获得天气数据http://wthrcdn.etouch.cn/WeatherApi?citykey=101010100// 通过城市名字获得天气数据http://wthrcdn.etouch.cn/WeatherApi?city=北京 返回数据: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177&lt;resp&gt;&lt;city&gt;北京&lt;/city&gt;&lt;updatetime&gt;09:45&lt;/updatetime&gt;&lt;wendu&gt;-1&lt;/wendu&gt;&lt;fengli&gt;2级&lt;/fengli&gt;&lt;shidu&gt;37%&lt;/shidu&gt;&lt;fengxiang&gt;西风&lt;/fengxiang&gt;&lt;sunrise_1&gt;07:08&lt;/sunrise_1&gt;&lt;sunset_1&gt;16:53&lt;/sunset_1&gt;&lt;sunrise_2/&gt;&lt;sunset_2/&gt;&lt;environment&gt;&lt;aqi&gt;43&lt;/aqi&gt;&lt;pm25&gt;20&lt;/pm25&gt;&lt;suggest&gt;各类人群可自由活动&lt;/suggest&gt;&lt;quality&gt;优&lt;/quality&gt;&lt;MajorPollutants/&gt;&lt;o3&gt;15&lt;/o3&gt;&lt;co&gt;1&lt;/co&gt;&lt;pm10&gt;42&lt;/pm10&gt;&lt;so2&gt;12&lt;/so2&gt;&lt;no2&gt;45&lt;/no2&gt;&lt;time&gt;10:00:00&lt;/time&gt;&lt;/environment&gt;&lt;yesterday&gt;&lt;date_1&gt;22日星期二&lt;/date_1&gt;&lt;high_1&gt;高温 0℃&lt;/high_1&gt;&lt;low_1&gt;低温 -8℃&lt;/low_1&gt;&lt;day_1&gt;&lt;type_1&gt;晴&lt;/type_1&gt;&lt;fx_1&gt;北风&lt;/fx_1&gt;&lt;fl_1&gt;3-4级&lt;/fl_1&gt;&lt;/day_1&gt;&lt;night_1&gt;&lt;type_1&gt;多云&lt;/type_1&gt;&lt;fx_1&gt;无持续风向&lt;/fx_1&gt;&lt;fl_1&gt;微风&lt;/fl_1&gt;&lt;/night_1&gt;&lt;/yesterday&gt;&lt;forecast&gt;&lt;weather&gt;&lt;date&gt;23日星期三&lt;/date&gt;&lt;high&gt;高温 3℃&lt;/high&gt;&lt;low&gt;低温 -6℃&lt;/low&gt;&lt;day&gt;&lt;type&gt;晴&lt;/type&gt;&lt;fengxiang&gt;无持续风向&lt;/fengxiang&gt;&lt;fengli&gt;微风级&lt;/fengli&gt;&lt;/day&gt;&lt;night&gt;&lt;type&gt;晴&lt;/type&gt;&lt;fengxiang&gt;无持续风向&lt;/fengxiang&gt;&lt;fengli&gt;微风级&lt;/fengli&gt;&lt;/night&gt;&lt;/weather&gt;&lt;weather&gt;&lt;date&gt;24日星期四&lt;/date&gt;&lt;high&gt;高温 4℃&lt;/high&gt;&lt;low&gt;低温 -6℃&lt;/low&gt;&lt;day&gt;&lt;type&gt;晴&lt;/type&gt;&lt;fengxiang&gt;无持续风向&lt;/fengxiang&gt;&lt;fengli&gt;微风级&lt;/fengli&gt;&lt;/day&gt;&lt;night&gt;&lt;type&gt;晴&lt;/type&gt;&lt;fengxiang&gt;无持续风向&lt;/fengxiang&gt;&lt;fengli&gt;微风级&lt;/fengli&gt;&lt;/night&gt;&lt;/weather&gt;&lt;weather&gt;&lt;date&gt;25日星期五&lt;/date&gt;&lt;high&gt;高温 4℃&lt;/high&gt;&lt;low&gt;低温 -5℃&lt;/low&gt;&lt;day&gt;&lt;type&gt;多云&lt;/type&gt;&lt;fengxiang&gt;无持续风向&lt;/fengxiang&gt;&lt;fengli&gt;微风级&lt;/fengli&gt;&lt;/day&gt;&lt;night&gt;&lt;type&gt;雾&lt;/type&gt;&lt;fengxiang&gt;无持续风向&lt;/fengxiang&gt;&lt;fengli&gt;微风级&lt;/fengli&gt;&lt;/night&gt;&lt;/weather&gt;&lt;weather&gt;&lt;date&gt;26日星期六&lt;/date&gt;&lt;high&gt;高温 5℃&lt;/high&gt;&lt;low&gt;低温 -5℃&lt;/low&gt;&lt;day&gt;&lt;type&gt;雾&lt;/type&gt;&lt;fengxiang&gt;无持续风向&lt;/fengxiang&gt;&lt;fengli&gt;微风级&lt;/fengli&gt;&lt;/day&gt;&lt;night&gt;&lt;type&gt;晴&lt;/type&gt;&lt;fengxiang&gt;无持续风向&lt;/fengxiang&gt;&lt;fengli&gt;微风级&lt;/fengli&gt;&lt;/night&gt;&lt;/weather&gt;&lt;weather&gt;&lt;date&gt;27日星期天&lt;/date&gt;&lt;high&gt;高温 5℃&lt;/high&gt;&lt;low&gt;低温 -5℃&lt;/low&gt;&lt;day&gt;&lt;type&gt;晴&lt;/type&gt;&lt;fengxiang&gt;无持续风向&lt;/fengxiang&gt;&lt;fengli&gt;微风级&lt;/fengli&gt;&lt;/day&gt;&lt;night&gt;&lt;type&gt;晴&lt;/type&gt;&lt;fengxiang&gt;无持续风向&lt;/fengxiang&gt;&lt;fengli&gt;微风级&lt;/fengli&gt;&lt;/night&gt;&lt;/weather&gt;&lt;/forecast&gt;&lt;zhishus&gt;&lt;zhishu&gt;&lt;name&gt;晨练指数&lt;/name&gt;&lt;value&gt;不宜&lt;/value&gt;&lt;detail&gt;早晨天气寒冷，请尽量避免户外晨练，若坚持室外晨练请注意保暖防冻，建议年老体弱人群适当减少晨练时间。&lt;/detail&gt;&lt;/zhishu&gt;&lt;zhishu&gt;&lt;name&gt;舒适度&lt;/name&gt;&lt;value&gt;较不舒适&lt;/value&gt;&lt;detail&gt;白天天气晴好，但仍会使您感觉偏冷，不很舒适，请注意适时添加衣物，以防感冒。&lt;/detail&gt;&lt;/zhishu&gt;&lt;zhishu&gt;&lt;name&gt;穿衣指数&lt;/name&gt;&lt;value&gt;冷&lt;/value&gt;&lt;detail&gt;天气冷，建议着棉服、羽绒服、皮夹克加羊毛衫等冬季服装。年老体弱者宜着厚棉衣、冬大衣或厚羽绒服。&lt;/detail&gt;&lt;/zhishu&gt;&lt;zhishu&gt;&lt;name&gt;感冒指数&lt;/name&gt;&lt;value&gt;较易发&lt;/value&gt;&lt;detail&gt;天气较凉，较易发生感冒，请适当增加衣服。体质较弱的朋友尤其应该注意防护。&lt;/detail&gt;&lt;/zhishu&gt;&lt;zhishu&gt;&lt;name&gt;晾晒指数&lt;/name&gt;&lt;value&gt;基本适宜&lt;/value&gt;&lt;detail&gt;天气不错，午后温暖的阳光仍能满足你驱潮消霉杀菌的晾晒需求。&lt;/detail&gt;&lt;/zhishu&gt;&lt;zhishu&gt;&lt;name&gt;旅游指数&lt;/name&gt;&lt;value&gt;较适宜&lt;/value&gt;&lt;detail&gt;天气较好，同时又有微风伴您一路同行。稍冷，较适宜旅游，您仍可陶醉于大自然的美丽风光中。&lt;/detail&gt;&lt;/zhishu&gt;&lt;zhishu&gt;&lt;name&gt;紫外线强度&lt;/name&gt;&lt;value&gt;弱&lt;/value&gt;&lt;detail&gt;紫外线强度较弱，建议出门前涂擦SPF在12-15之间、PA+的防晒护肤品。&lt;/detail&gt;&lt;/zhishu&gt;&lt;zhishu&gt;&lt;name&gt;洗车指数&lt;/name&gt;&lt;value&gt;较适宜&lt;/value&gt;&lt;detail&gt;较适宜洗车，未来一天无雨，风力较小，擦洗一新的汽车至少能保持一天。&lt;/detail&gt;&lt;/zhishu&gt;&lt;zhishu&gt;&lt;name&gt;运动指数&lt;/name&gt;&lt;value&gt;较不宜&lt;/value&gt;&lt;detail&gt;天气较好，但考虑天气寒冷，推荐您进行各种室内运动，若在户外运动请注意保暖并做好准备活动。&lt;/detail&gt;&lt;/zhishu&gt;&lt;zhishu&gt;&lt;name&gt;约会指数&lt;/name&gt;&lt;value&gt;较不适宜&lt;/value&gt;&lt;detail&gt;天气较冷，室外约会可能会让恋人们受些苦，可在温暖的室内促膝谈心。&lt;/detail&gt;&lt;/zhishu&gt;&lt;zhishu&gt;&lt;name&gt;雨伞指数&lt;/name&gt;&lt;value&gt;不带伞&lt;/value&gt;&lt;detail&gt;天气较好，您在出门的时候无须带雨伞。&lt;/detail&gt;&lt;/zhishu&gt;&lt;/zhishus&gt;&lt;/resp&gt;&lt;!-- 10.10.156.163(10.10.156.163):57635 ; 10.10.156.163:8080--&gt; 其他:聚合数据 12// 网站地址 站内提供不限次免费API接口https://www.juhe.cn/docs/api/id/73 抓包中华万年历Java代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import net.sf.json.JSONArray;import net.sf.json.JSONObject;import org.apache.http.HttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.HttpClientBuilder;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 抓取中华万年历天气接口,可用接口包括 * ①通过城市名字获取天气 * URL http://wthrcdn.etouch.cn/weather_mini?city=北京 * return JSON * URL http://wthrcdn.etouch.cn/WeatherApi?city=北京 * return XML * ②通过城市代码(中国天气网城市代码)获取天气 * URL http://wthrcdn.etouch.cn/weather_mini?citykey=101010100 * return JSON * URL http://wthrcdn.etouch.cn/WeatherApi?citykey=101010100 * return XML * 可选聚合数据免费不限次API * URL https://www.juhe.cn/docs/api/id/73 * @author TilKai */public class WthrcdnWeatherUtils &#123; public static Map&lt;String, String&gt; getWeatherByCityName (String cityName) &#123; String wthrcdnWeatherUrl = &quot;http://wthrcdn.etouch.cn/weather_mini?city=&quot; + cityName; HttpGet request = new HttpGet(wthrcdnWeatherUrl); request.addHeader(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36&quot;); List&lt;Map&lt;String, String&gt;&gt; weatherListInfo = null; Map&lt;String,String&gt; weatherMap = new HashMap&lt;String, String&gt;(); try &#123; HttpResponse response = HttpClientBuilder.create().build().execute(request); if (response.getStatusLine().getStatusCode() == 200) &#123; BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), &quot;utf-8&quot;)); StringBuffer resultStr = new StringBuffer(); String line; while ((line = bufferedReader.readLine()) != null) &#123; resultStr.append(line); &#125; System.out.println(resultStr); JSONObject tempJsonObject1 = JSONObject.fromObject(resultStr.toString()); String tempStr = tempJsonObject1.get(&quot;data&quot;).toString(); JSONObject tempJsonObject2 = JSONObject.fromObject(tempStr); String tempStr1 = tempJsonObject2.get(&quot;forecast&quot;).toString(); String city = tempJsonObject2.get(&quot;city&quot;).toString(); // 城市 String week = ((JSONObject) JSONArray.fromObject(tempStr1).get(0)).get(&quot;date&quot;).toString().split(&quot;日&quot;)[1]; // 星期 String highTemperature = ((JSONObject) JSONArray.fromObject(tempStr1).get(0)).get(&quot;high&quot;).toString().substring(3); // 最高温 String lowTemperature = ((JSONObject) JSONArray.fromObject(tempStr1).get(0)).get(&quot;low&quot;).toString().substring(3); // 最低温 String type = ((JSONObject) JSONArray.fromObject(tempStr1).get(0)).get(&quot;type&quot;).toString(); // 天气类型 weatherMap.put(&quot;week&quot;, week); weatherMap.put(&quot;city_name&quot;, city); weatherMap.put(&quot;s1s2&quot;, type); weatherMap.put(&quot;t1&quot;, highTemperature); weatherMap.put(&quot;t2&quot;, lowTemperature); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; return weatherMap; &#125; &#125; public static void main (String []args) &#123; WthrcdnWeatherUtils wthrcdnWeatherUtils = new WthrcdnWeatherUtils(); Map&lt;String, String&gt; weatherList = wthrcdnWeatherUtils.getWeatherByCityName(&quot;北京&quot;); System.out.println(weatherList); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于SpringBoot实现MotanDemo]]></title>
      <url>%2F2016%2F12%2F08%2F%E5%9F%BA%E4%BA%8ESpring-boot%E5%AE%9E%E7%8E%B0Motan-Demo%2F</url>
      <content type="text"><![CDATA[首先了解RPC 参考 : 知乎-谁能用通俗的语言解释一下什么是 RPC 框架？ (身份验证可能使用Netty实现。)将函数的参数和要调用的函数的名称作为协议的一部分，达成RPC.表现出来的特性就是，object invok(parameter)，就代表了，序列化 parameter 对象到中间格式，利用远程服务器的 invok 函数进行处理 ，同时将返回的数据解码生成 object对象。完成RPC需要两个协议:对象序列化协议和调用控制协议; 生产环境中需要考虑stub怎么生成,序列化怎么最高效,如何统一不同机器之前的调用,(大小端的机器等),如何识别该调用哪个机器,负载均衡.socket通信.等等. 简单描述Motan框架Motan架构包括: . 服务提供方Server . 服务调用方Client . 注册中心Registry流程大致为:Server向Registry注册服务；Client向Registry订阅指定服务;Client获取Registry返回的服务列表后连接Server；Client通过Registry感知Server的状态变更； MotanDemo官方下载地址 Motan依赖pom中: 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;com.weibo&lt;/groupId&gt; &lt;artifactId&gt;motan-core&lt;/artifactId&gt; &lt;version&gt;0.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.weibo&lt;/groupId&gt; &lt;artifactId&gt;motan-transport-netty&lt;/artifactId&gt; &lt;version&gt;0.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- dependencies blow were only needed for spring-based features --&gt;&lt;dependency&gt; &lt;groupId&gt;com.weibo&lt;/groupId&gt; &lt;artifactId&gt;motan-springsupport&lt;/artifactId&gt; &lt;version&gt;0.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; gradle中: 1234compile(&quot;com.weibo:motan-core:0.2.2&quot;)compile(&quot;com.weibo:motan-transport-netty:0.2.2&quot;)compile(&quot;com.weibo:motan-springsupport:0.2.2&quot;)compile(&quot;org.springframework:spring-context:4.2.4.RELEASE&quot;) 通过注解实现Motan Demo为服务提供方和服务调用方创建规范接口123public interface HelloWorld &#123; public String hello(String name);&#125; 服务端创建基于规范接口的实现类1234567@MotanService(export = &quot;8002&quot;)public class HelloWorldImpl implements HelloWorld &#123; public String hello(String name) &#123; System.out.println(name); return &quot;Hello &quot; + name + &quot;!&quot;; &#125;&#125; 服务端创建服务暴露类,服务暴露类里定义带有如下返回值的方法返回值类型为AnnotationBean的bean定义,该方法指定待解析的包名123456@Beanpublic AnnotationBean motanAnnotationBean() &#123; AnnotationBean annotationBean = new AnnotationBean(); motanAnnotationBean.setPackage(&quot;com.weibo.motan.demo.server&quot;); return motanAnnotationBean;&#125; 此处指定的是HelloWorldImpl所在的包目录(指定到类好像也成立) 返回类型为ProtocolConfigBean的bean定义,该方法做协议配置12345678@Bean(name = &quot;demoMotan&quot;)public ProtocolConfigBean protocolConfig() &#123; ProtocolConfigBean config = new ProtocolConfigBean(); config.setDefault(true); config.setName(&quot;motan&quot;); config.setMaxContentLength(1048576); return config;&#125; 返回值类型为RegistryConfigBean的bean定义,该方法用于配置注册中心123456@Bean(name = &quot;registryConfig&quot;)public RegistryConfigBean registryConfig() &#123; RegistryConfigBean config = new RegistryConfigBean(); config.setRegProtocol(&quot;local&quot;); return config;&#125; 返回值类型为BasicServiceConfigBean的bean定义,该方法提供服务暴露或引用时所需要的配置项123456789101112@Beanpublic BasicServiceConfigBean baseServiceConfig() &#123; BasicServiceConfigBean config = new BasicServiceConfigBean(); config.setExport(&quot;demoMotan:8002&quot;); config.setGroup(&quot;testgroup&quot;); config.setAccessLog(false); config.setShareChannel(true); config.setModule(&quot;motan-demo-rpc&quot;); config.setApplication(&quot;myMotanDemo&quot;); config.setRegistry(&quot;registryConfig&quot;); return config;&#125; 服务端main方法12345public static void main(String[] args) &#123; //System.setProperty(&quot;server.port&quot;, &quot;8081&quot;); ConfigurableApplicationContext context = SpringApplication.run(SpringBootRpcServerDemo.class, args); //MotanSwitcherUtil.setSwitcherValue(MotanConstants.REGISTRY_HEARTBEAT_SWITCHER, true);&#125; 客户端端创建服务引用类,服务引用类里定义带有如下返回值的方法返回值类型为AnnotationBean的bean定义,该方法指定待解析的包名123456@Beanpublic AnnotationBean motanAnnotationBean() &#123; AnnotationBean annotationBean = new AnnotationBean(); motanAnnotationBean.setPackage(&quot;com.weibo.motan.demo.client.control&quot;); return motanAnnotationBean;&#125; &#35813;&#x5904;&#x6307;&#23450;&#99;&#x6f;&#x6e;&#116;&#114;&#x6f;&#108;&#x6c;&#x65;&#x72;&#x5305;&#44;&#35299;&#26512;&#x40;&#77;&#x6f;&#x74;&#97;&#110;&#82;&#x65;&#102;&#101;&#114;&#101;&#114;&#x6ce8;&#x89e3;&#x7684;&#x5bf9;&#x8c61; 返回类型为ProtocolConfigBean的bean定义与服务端配置相同即可; 返回值类型为RegistryConfigBean的bean定义与服务端配置相同即可; 返回值类型为BasicRefererConfigBean的bean定义1234567891011121314@Bean(name = &quot;clientBasicConfig&quot;) public BasicRefererConfigBean baseRefererConfig() &#123; BasicRefererConfigBean config = new BasicRefererConfigBean(); config.setProtocol(&quot;demoMotan&quot;); config.setGroup(&quot;motan-demo-rpc&quot;); config.setModule(&quot;motan-demo-rpc&quot;); config.setApplication(&quot;myMotanDemo&quot;); config.setRegistry(&quot;registry&quot;); config.setCheck(false); config.setAccessLog(true); config.setRetries(2); config.setThrowException(true); return config; &#125; controller中将注入的待暴露接口加上@MotanReferer注解123@Autowrired@MotanReferer(basicReferer = &quot;clientBasicConfig&quot;, group = &quot;testgroup&quot;, directUrl = &quot;127.0.0.1:8002&quot;)HelloWorld helloWorld; 以上操作完成配置问题解决: 中间出现过log4j包引用冲突的问题,解决办法: build.gradle中添加 123configurations &#123; all*.exclude group: &apos;org.slf4j&apos;, module: &apos;slf4j-log4j12&apos;&#125; 如果接口规范在单独的module中,需要在client和server的module的build.gradle中添加对接口规范类所在module的依赖,dependencies中添加: 1compile project(&apos;:module名称&apos;) 参考:spring-boot motan 整合 GitHub]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swagger-API]]></title>
      <url>%2F2016%2F12%2F06%2FSwagger-API%2F</url>
      <content type="text"><![CDATA[Swagger常用注解一览及使用 注:本文基于1.5X版本 @API @API: Marks a class as a Swagger resource. 表示一个开放的API，①value: 定义API声明资源的托管路径，一般与@path具有相同的值，若使用tags属性，则value标记失效；②description: 简短描述API功能，1.5x版本不再使用，Default = “”；③produces: 指定API输出的MIME(Multipurpose Internet Mail Extensions)类型，value可以为逗号分隔的内容，如produces = &quot;application/json, application/xml&quot;会建议该API Resource生成JSON和XML输出，Default = “”;④position: 定义该API Resource在资源清单中显式排顺的顺序，1.5x不再使用，保留作为向前支持，Default = 0;⑤consumes: 指定输入，value定义可使用逗号分隔的内容，如consumes = &quot;application/json, application/xml&quot;会建议该API Resource接收JSON和xml类型的输入，Default = “”;⑥protocols: 为此资源下的操作设定特定协议，值为字符串，可用逗号分隔设定多个协议，可选值有” http, https, ws, wss”;⑦authorizations: 对应操作对象的’security’字段，获取该API Resource所需的授权列表，default = @com.wordnik.swagger.annotations.Authorization(“”);⑧hidden: 隐藏该API Resource，实验证明定义在@API中未被使用，而定义在@ApiOperation中时，设置为true可隐藏该方法，Default = false;⑨tags: 定义API文档控件的标签列表，用于分组展示，非空值时，覆盖value中的值，数据类型为string类型的List;⑩basePath: 1.5x不再使用，保留作为向前支持; 1@Api(value = &quot;/IndexController&quot;, tags = &#123;&quot;API1&quot;, &quot;API2&quot;&#125;, description = &quot;Swagger接口示例&quot;, produces = MediaType.APPLICATION_JSON_VALUE, position = 0, consumes = &quot;application/json, application/xml&quot;, hidden = false) @ApiImplicitParam @ApiImplicitParam:Represents a single parameter in an API Operation. While ApiParam is bound to a JAX-RS parameter, method or field, this allows you to manually define a parameter in a fine-tuned manner. This is the only way to define parameters when using Servlets or other non-JAX-RS environments.This annotation must be used as a value of ApiImplicitParams in order to be parsed. ①name: Name of the parameter.为了使Swagger功能正常，当根据paramType()命名参数时，官方要求遵循如下规则: .如果参数类型为路径，name应该为路径中的相关节点; .如果参数类型为body,name应该为body; .对于其他情况，参数名称应该为应用程序期望的参数名称;②value: a brief description of the parameter 参数的一个临时描述;③defaultValue: Describes the default value for the parameter 参数默认值的描述;④allowableValues: 限制参数可接收的值,官方提供三种方式描述可接收的值: To set a list of values, provide a comma-separated list surrounded by square brackets. For example: [first, second, third].(直译来看,官方讲的是方括号括起来的逗号分隔的列表，即数组,但这是个坑!直接使用逗号分隔的值的字符串就好了,像可选值为”a”,”b”,”c”,不要写[“a”,”b”,”c”],直接写”a,b,c”吧!) range定义包括或不包括最大值最小值的数值范围，如range[1,5]，range[1,5)，方括号包括临界值，圆括号不包括临界值; range定义从-infinity或到infinity的数组范围，如range[1,infinity]或range[-infinity,1]⑤required: 描述参数是否为必须;⑥access: 允许从API文档过滤参数，Default = “”，具体参阅io.swagger.core.filter.SwaggerSpecFilter;⑦allowMultiple: 指定参数是否允许接收多个逗号分隔的值, Default = false;⑧dataType: 指定数据类型，官方指定允许原始数据类型或类名, Default = “”;⑨paramType: 指定参数类型，官方指定参数包括”path”(请求参数的获取@PathVariable),”query”(请求参数的获取@RequestParam),”body”(不常用),”header”(请求参数的获取@ReuqestHeader),”form”(不常用); 1@ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, defaultValue = &quot;&quot;, allowableValues = &quot;range[-infinity, 1]&quot;, required = true, allowMultiple = true, dataType = &quot;int&quot;, paramType = &quot;path&quot;) @ApiImplicitParams @ApiImplicitParams: A list of ApiImplicitParams available to the API operation. 1234@ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, paramType = &quot;path&quot;, dataType = &quot;int&quot;), @ApiImplicitParam(name = &quot;userName&quot;,value = &quot;用户名称&quot;,paramType = &quot;form&quot;,dataType = &quot;string&quot;)&#125;) @ApiModel @ApiModel: 提供有关Swagger models的额外的信息。适用于实体类，而不适用于方法。 Default = “” ①value: 提供给model一个可替代的名称，默认为类名；②description:提供给类一个长的描述，Default = “”；③parent: 内容为实体继承的父类，用于描述实体的继承关系，Default = java.lang.Void.class；④discriminator: 支持模型的继承和多态。用作鉴别符的字段名称，基于该字段，可以鉴别使用哪个子类， Default = “”；⑤subType: 继承于该模型的子类集合，Default = {}；⑥reference: 指定类型引用，可被覆盖。Default = “”; 123456@ApiModel(description = &quot;电站基本信息&quot;)@Entity@JsonInclude(JsonInclude.Include.NON_NULL)public class Station implements Serializable &#123; // ...&#125; @ApiModelProperty @ApiModelProperty: 用于添加或操纵实体的属性；可将@ApiModelProperty注解用于实体的getter方法上，如: 1234567891011121314@ApiModel(description = &quot;电站基本信息&quot;)@Entity@JsonInclude(JsonInclude.Include.NON_NULL)public class Station implements Serializable &#123; protected static final long serialVersionUID = 1L; @Id @GeneratedValue protected Long id; // ... @ApiModelProperty(example = &quot;1&quot;, value = &quot;电站ID&quot;) public Long getId() &#123; return id; &#125;&#125; ①value: 该属性的简单描述②allowableValues: 该属性允许的限制值；允许用以下三种方式定义: .类似于allowableValues = &quot;1,2,3,4&quot;(官方给出的是类似于allowableValues = &quot;[1,2,3,4]&quot;，不好用！)； .类似于allowableValues = &quot;range[1,5]&quot;或allowableValues = &quot;range[1,5)&quot;，使用方括号代表包括临界值，使用圆括号表示不包括临界值，实践得到方括号生成的值正常(id (integer, optional): 电站ID integerMin. Value:1Max. Value:5,)，而圆括号不能正常生产对应的范围(id (integer, optional): 电站ID integerMin. Value:1,) 类似于allowableValues = &quot;(0,9)&quot;，实践证明不好用，解决后更新此处！③access: 允许从API文档中过滤属性，Default = “”；实践未找到如何使用④notes: 暂未使用，Default = “”；⑤dataType: 定义参数的数据类型，用于覆盖从类中读取到的属性的数据类型，Default = “”；⑥required: 指定参数是否为必须的，Default = false；⑦position: 在模型中显式的定义属性的显示顺序，Default = 0；⑧hidden: 允许属性在swagger-api中隐藏，Default = false(像如果前后端不传输某属性，可以直接加@JsonIgnore注解)；通过ApiModelProperty注解的example属性设置响应对象的示例;⑨name: 允许覆盖属性名。Default = “”;⑩readOnly:true||false,允许指定模型属性为只读;⑪reference: 指定类型引用，覆盖其他指定类型; 12@ApiModelProperty(value = &quot;ID&quot;, name = &quot;&quot;, allowableValues = &quot;range[0, 999]&quot;, dataType = &quot;int&quot;, required = false, position = 0, hidden = false, example = &quot;1&quot;, readOnly = false, reference = &quot;&quot;)private int id; @ApiOperation @ApiOperation:Describes an operation or typically a HTTP method against a specific path.描述针对特定路径的操作或通常的HTTP方法。 一个@API下可以有多个@ApiOperation，表示针对该API的CRUD操作，在ApiOperation Annotaiton中还可用value，notes描述该操作的应用，response描述正常情况下该请求返回的对象类型. ①value: Provides a brief description of this operation. Should be 120 characters or less for proper visibility in Swagger-UI.提供该操作的简短描述，为了在Swagger-ui中的正确可见性，value应小于等于120个字符。②notes: A verbose description of the operation. 提供该操作的详细说明。③response: The response type of the operation.In JAX-RS applications, the return type of the method would automatically be used, unless it is javax.ws.rs.core.Response. In that case, the operation return type would default to void as the actual response type cannot be known.操作的响应类型。在JAX-RS应用中，将自动使用方法的返回值类型，除非应用是javax.ws.rs.core.Response时，操作的返回值类型为void，因为实际的响应类型是未知的。(实际应用中,可能有List&lt;HelloWord&gt;返回值的情况,此时可以配置:response = HelloWord.class, responseContainer = “List”, 定义为List&lt;HelloWord&gt;的返回值展示示例)④responseContainer: Notes whether the response type is a list of values.Valid values are “List”, “Array” and “Set”. “List” and “Array” are regular lists (no difference between them), and “Set” means the list contains unique values only.Any other value will be ignored.注意响应类型是否为list。有效值为List、Array、Set。常规值为List、Array(两者没区别)，特殊值为Set，其他值被忽略。⑤tags: 目前未被使用。⑥httpMethod: Corresponds to the method field as the HTTP method used.If not stated, in JAX-RS applications, the following JAX-RS annotations would be scanned and used: @GET, @HEAD, @POST, @PUT, @DELETE and @OPTIONS. Note that even though not part of the JAX-RS specification, if you create and use the @PATCH annotation, it will also be parsed and used. If the httpMethod property is set, it will override the JAX-RS annotation. For Servlets, you must specify the HTTP method manually. Acceptable values are “GET”, “HEAD”, “POST”, “PUT”, “DELETE”, “OPTIONS” and “PATCH”. 对应method字段作为使用的HTTP方法，若没有特殊说明，在JAX-RS程序中，将扫描和使用以下JAX-RS注释：@GET，@HEAD，@POST，@PUT，@ DELETE和@OPTIONS。 注意，即使不是JAX-RS规范的一部分，如果创建和使用@PATCH注释，它也将被解析和使用。 如果设置了httpMethod属性，它将覆盖JAX-RS注释。 对于Servlet，必须手动指定HTTP方法。 可接受的值为“GET”，“HEAD”，“POST”，“PUT”，“DELETE”，“OPTIONS”和“PATCH”。⑦position⑧nickname: Corresponds to the nickname field.The nickname field is used by third-party tools to uniquely identify this operation. In JAX-RS environemnt, this would default to the method name, but can be overridden. For Servlets, you must specify this field. 对应nickname字段。该昵称字段用于第三方工具识别。JAX-RS环境中，这将默认作为方法名，但可覆盖。⑨produces、consumes、protocols、authorizations、hidden⑩tags: 定义标签用于逻辑分组，非空时覆盖@Api.value()和@Api.tags()的值，此处为字符串而非集合(官方说法)，实际上，如果定义与@Api.tags()的相同，则无效果，如果不同，会新建标签; 1@ApiOperation(value=&quot;获取用户列表&quot;, notes=&quot;获取所有用户列表&quot;, response = HelloWorld.class, httpMethod = &quot;GET&quot;, produces = MediaType.APPLICATION_JSON_VALUE, position = 1) @ApiParam @ApiParam:用于描述该API操作接收的参数类型，value用于描述参数，required用于描述是否为必须；注意@ApiParam只与JAX-RS参数注释一起使用，JAX-RS参数包括:@PathParam,@QueryParam,@HeaderParam,@FormParam和在JAX-RS2中的@BeanParam. ①name: name从字段、方法、参数名派生，可被覆盖。body始终命名为”body”，路径始终命名为其所表示的路径;②value: A brief description of the parameter;③defaultValue: 描述默认值;④allowableValues: 参数可接收值的列表，有如下格式可被接收[1,2,3] || range[1, 5] || range[-infinity, 0];⑤required: Specifies if the parameter is required or not.⑥access: Default = “”;⑦allowMultiple: true || false; 123456@ApiOperation(notes = &quot;user/loadUser.do&quot;,value = &quot;获取用户&quot;, httpMethod = &quot;GET&quot;, produces = MediaType.APPLICATION_JSON_VALUE)public Result loadUser( @ApiParam(value = &quot;用户ID&quot;, required = true) @RequestParam Long userId)&#123; ...&#125; @ApiResponse @ApiResponse:①code: The HTTP status code of the response.②message: 与code对应的人类可读的信息。③response: 可选的响应类，描述消息的有效内容,如错误时返回Map形式的User对象,则可以设置response=User.class,responseContainer=”Map”。④responseContainer: 可选的response的展示形式,可选值列表为List、Map、Set,设置其他值将被忽略。 @ApiResponses @ApiResponses:在一个@ApiOperation下，可以通过@ApiResponses描述API操作可能出现的异常情况(或其他成功信息)①value: 存放@ApiResponse列表。 示例一(像代码中拦截捕获的异常并进行处理，将拦截内容加工放入ErrorInfo实体中，就可以像下面一样定义): 1@ApiResponses(value = &#123;@ApiResponse(code = 405, message = &quot;Invalid input&quot;, response = ErrorInfo.class), responseContainer = &quot;Map&quot;&#125;) 示例二(添加响应头的描述): 1234@ApiResponses(value = &#123; @ApiResponse(code = 400, message = &quot;Invalid ID supplied&quot;, responseHeaders = @ResponseHeader(name = &quot;X-Rack-Cache&quot;, description = &quot;Explains whether or not a cache was used&quot;, response = Boolean.class)), @ApiResponse(code = 404, message = &quot;Pet not found&quot;) &#125;) @Authorization @Authorization和@AuthorizationScope:注解仅用作@Api和@ApiOperation的输入，并不直接用于资源和操作，当直接在类或方法上使用它们将被忽略；当声明并配置了API支持的授权方案后，你就可以用这些注解去标注资源或特殊操作的授权方案；The authorization scheme used needs to be defined in the Resource Listing’s authorization section. This annotation is not used directly and will not be parsed by Swagger. It should be used within either Api or ApiOperation. ①name: 该资源或操作中的授权文件的名称。②scopes: 当授权文件为OAuth2是被使用。 @AuthorizationScope @AuthorizationScope: 该注解特定用于OAuth2.0授权方案的时候；①scope: OAuth2授权时被使用。②description: 关于scope的简短描述。 123456789@ApiOperation(value = &quot;Add a new pet to the store&quot;, authorizations = &#123; @Authorization( value=&quot;petoauth&quot;, scopes = &#123; @AuthorizationScope(scope = &quot;add:pet&quot;) &#125; ) &#125; ) public Response addPet(...) &#123;...&#125; 注意: . @ApiImplicitParams会覆盖@ApiParam中的配置. . 好多属性在API中定义了，调用其中方法时却没有起到作用，是被覆盖了还是未起作用？定义的意义何在。 . @ApiModelProperty在界面的什么地方体现了。 附录: 官方文档1官方文档2(详细)GitHub官方文档1.5X在线编辑器,提供部分实例下载如何编写基于OpenAPI规范的API文档123456&gt;&gt;---## Spring Boot整合Swagger-ui配置使用### 引入资源文件`build.gradle`中引入配置: compile(‘io.springfox:springfox-swagger2:2.6.1’)compile(‘io.springfox:springfox-swagger-ui:2.6.1’)12### 实现Swagger配置类: package com.tsingyun.XXX.center.config; import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2; /** Created by TilKai on 16/12/19.*/@EnableSwagger2@Configuration@ConditionalOnProperty(name = “swagger.enabled”, havingValue = “true”)public class SwaggerConfig { @Bean public Docket createRestApi() {return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.tsingyun.XXX.center&quot;)) .paths(PathSelectors.any()) .build(); }}1234### 配置开启swagger`application.yml`中配置开启swagger swagger: enabled : true``` 完成Spring Boot中Swagger的配置。 项目bootRun后点击此处执行]]></content>
    </entry>

    
  
  
</search>
